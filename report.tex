%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Template for USENIX papers.
%
% History:
%
% - TEMPLATE for Usenix papers, specifically to meet requirements of
%   USENIX '05. originally a template for producing IEEE-format
%   articles using LaTeX. written by Matthew Ward, CS Department,
%   Worcester Polytechnic Institute. adapted by David Beazley for his
%   excellent SWIG paper in Proceedings, Tcl 96. turned into a
%   smartass generic template by De Clarke, with thanks to both the
%   above pioneers. Use at your own risk. Complaints to /dev/null.
%   Make it two column with no page numbering, default is 10 point.
%
% - Munged by Fred Douglis <douglis@research.att.com> 10/97 to
%   separate the .sty file from the LaTeX source template, so that
%   people can more easily include the .sty file into an existing
%   document. Also changed to more closely follow the style guidelines
%   as represented by the Word sample file.
%
% - Note that since 2010, USENIX does not require endnotes. If you
%   want foot of page notes, don't include the endnotes package in the
%   usepackage command, below.
% - This version uses the latex2e styles, not the very ancient 2.09
%   stuff.
%
% - Updated July 2018: Text block size changed from 6.5" to 7"
%
% - Updated Dec 2018 for ATC'19:
%
%   * Revised text to pass HotCRP's auto-formatting check, with
%     hotcrp.settings.submission_form.body_font_size=10pt, and
%     hotcrp.settings.submission_form.line_height=12pt
%
%   * Switched from \endnote-s to \footnote-s to match Usenix's policy.
%
%   * \section* => \begin{abstract} ... \end{abstract}
%
%   * Make template self-contained in terms of bibtex entires, to allow
%     this file to be compiled. (And changing refs style to 'plain'.)
%
%   * Make template self-contained in terms of figures, to
%     allow this file to be compiled. 
%
%   * Added packages for hyperref, embedding fonts, and improving
%     appearance.
%   
%   * Removed outdated text.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{usenix-2020-09}

% to be able to draw some self-contained figs
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{makecell}

\renewcommand\theadalign{bc}
\renewcommand\theadfont{\bfseries}

% inlined bib file
\usepackage{filecontents}

%-------------------------------------------------------------------------------
\begin{filecontents}{\jobname.bib}
%-------------------------------------------------------------------------------
@Book{arpachiDusseau18:osbook,
  author =       {Arpaci-Dusseau, Remzi H. and Arpaci-Dusseau Andrea C.},
  title =        {Operating Systems: Three Easy Pieces},
  publisher =    {Arpaci-Dusseau Books, LLC},
  year =         2015,
  edition =      {1.00},
  note =         {\url{http://pages.cs.wisc.edu/~remzi/OSTEP/}}
}
@InProceedings{waldspurger02,
  author =       {Waldspurger, Carl A.},
  title =        {Memory resource management in {VMware ESX} server},
  booktitle =    {USENIX Symposium on Operating System Design and
                  Implementation (OSDI)},
  year =         2002,
  pages =        {181--194},
  note =         {\url{https://www.usenix.org/legacy/event/osdi02/tech/waldspurger/waldspurger.pdf}}}
\end{filecontents}

%-------------------------------------------------------------------------------
\begin{document}
%-------------------------------------------------------------------------------

%don't want date printed
\date{}

% make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf Research Proposal: \\Pruning Techniques for the Quanto Quantum Curcuit Optimizer}

%for single author (just remove % characters)
\author{
{\rm Max von Storch}\\
Technische Universität München
\and
{\rm Johannes Schielein}\\
Technische Universität München
% copy the following lines to add more authors
% \and
% {\rm Name}\\
%Name Institution
} % end author

\maketitle

%-------------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------------
This report is about Quanto, a quantum circuit optimizers with uses automated circuit identity generation, and our approach to optimize
it by pruning the space of possible circuits.   
\end{abstract}


%-------------------------------------------------------------------------------
\section{Part A: Paper Summary}
%-------------------------------------------------------------------------------

\subsection{Context of the work (``Why?'')}

Quantum compilers are used to optimize circuits in an effort to reduce execution time, the noise that naturally arises in quantum computations, or both. Generally, the larger the circuit depth, the noisier the computation, leading to more errors in the results. As quantum programs must be executed many times to obtain an accurate picture of their results, reducing the depth of a quantum circuit not only makes a quantum program faster but also reduces the potential for noise and decreases the number of program evaluations required. By optimizing the circuit, quantum compilers enhance the overall efficiency and reliability of quantum computations.
\\\\
Existing quantum compilers focus on mapping logical quantum circuits to quantum devices and their native quantum gates. This involves translating source gates to target gates and adapting the circuit to hardware constraints like qubit connectivity. Typically, only simple circuit identities are used during this process, which overlooks the potential for more complex optimizations.
\\\\
Compilers developed by hardware vendors, such as IBM and Google, primarily address the translation and hardware adaptation aspects but pay less attention to optimizing the logical circuit itself by finding comprehensive circuit identities. While circuit identities have been manually identified and automatically generated for single-qubit gates, no current system automatically finds identities for full gate sets or optimizes quantum circuits based on these identities.
\\\\
For example, the Verified Optimizer for Quantum Circuits (voqc) applies a limited set of optimization rules: not propagation, Hadamard reduction, single-qubit gate cancellation, two-qubit gate cancellation, and rotation merging, in a specific sequence. These limited rules restrict the potential for discovering more effective optimizations.
\subsection{Contributions of the work (``How?'')}

Quanto automatically generates circuit identities for full gate sets and operates trough two main phases: (1) Identity generation (2) circuit optimization (Fig. \ref{fig:quanto_system_design}).
\\\\
In the identity generation phase, all possible circuit identities are generated for a specified depth and number of qubits. These identities are stored in a hash table, using the hash of their unitary matrices as keys, enabling quick lookup by the optimizer.
\\\\
In the circuit optimization phase, the input quantum circuit is divided into smaller sub-circuits, or tiles. The optimizer looks up the fingerprint of each tile in the hash table to find equivalent circuit identities. These identities replace the original sub-circuits, iteratively optimizing the circuit until the most efficient version is achieved.

\subsubsection{Circuit Identity Generator}
\textbf{Step 1: Represent the quantum circuit as a grid.}
The algorithm starts by representing a quantum circuit as a grid. The number of rows $d$ represents the layers in the quantum circuit, also known as the circuit depth, and the number of columns $n$ represents the number of qubits. If no gate is present at a particular position, the identity gate is placed there (Fig. \ref{fig:quanto_example_grid}).
\\\\
\textbf{Step 2: Generation of all possible circuits for $d = 1$.}
If the gate set contains two-qubit gates, these gates are split into the first and second qubit they operates on (Fig. \ref{}).
\\\\
\textbf{Step 3: Generation of all possible circuits for $d > 1$.}
All subsequent circuits are generated by iteratively appending circuits of depth one ($d=1$) to each previously generated circuit. This process effectively generates the "cross-product" of circuits with the current depth and circuits of depth one (Fig. \ref{}).
\\\\
\textbf{Step 4: Calculation of unitary matrices and hash values.}
For each generated circuit, the algorithm calculates the unitary matrix. To avoid expensive computations repeatedly, it computes a hash value (fingerprint) for each circuit based on its unitary matrix. This fingerprint uniquely identifies the circuit's functionality.
\\\\
\textbf{Step 6: Create fingerprint database.}
The fingerprints are stored in a hash table, with the circuit structure as the key and the fingerprint as the value (Fig. \ref{}). This enables quick look-up of a circuit’s fingerprint during the optimization phase without recalculating the unitary matrix.
\\\\
\textbf{Step 7: Create identity database.}
Circuits with identical fingerprints are stored together, forming equivalence classes of circuits (Fig. \ref{}). Each entry in this hash table represents a set of circuits that perform the same quantum operation but may have different structures.

\subsubsection{Circuit Optimizer}
\textbf{Step 1: Generate tiles.}
The circuit is divided into sub-circuits, referred to as tiles. Tiles have uniform dimensions, with the tile width $j$ representing the maximum depth $d$ of the circuit identities, and the tile length $i$ representing the maximum number of qubits $n$. The number of possible $i \times j$ tiles for an $n \times d$ circuit is $(n-i+1) \cdot (d-j+1)$.
\\\\
\textbf{Step 2: Check tile validity.}
A tile is invalid and therefore discarded if it contains a two-qubit gate that is not placed at the boundaries of the tile and is cut off by the tile (Fig. \ref{}).
\\\\
\textbf{Step 3: Tile lookup.}
If a tile contains a two-qubit gate, that has been cut off only at the boundaries of the tile, the cut off gate has to be replaced by an Identity gate, so that there will be a match in the circuit identity database (Fig. \ref{}). Now the fingerprint is retrieved from the fingerprint database, without having to calculate the unitary matrix. 
\\\\
\textbf{Step 4: Apply substitution.}
For each tile, the corresponding circuit identities are iterated and evaluated by the customizable cost function. In the paper, the cost function optimizes the circuit according to the depth $d$ of the circuit. 
\\\\
\textbf{Step 5: Apply substitution to the circuit.}
The optimizer applies the substitution to the quantum circuit (Fig. \ref{}). If a $CX$ gate was replaced by an identity gate in the tile, the identity gate in the actual circuit must be replaced by a $CX$ gate during the substitution (Fig. \ref{}). 
\\\\
\textbf{Step 6: Repeat process.}
Repeat steps 1-6 for a fixed number of times.

\subsection{Evaluation}
\subsubsection{Generation of novel identities}
Quanto is capable of automatically discovering identities known from previous work and generating novel identities, especially for two-qubit gates. By leveraging its automated circuit identity generation capabilities, Quanto can find optimizations that are not identified by other compilers (Fig. \ref{}). For example, in evaluating the IBM Qiskit compiler, Quanto generated novel circuit identities that the Qiskit compiler could not find. This capability is particularly useful for quantum hardware with non-standard native gate sets.
\subsubsection{Challenge of scalability}
One of the main challenges faced by Quanto is scalability. The vast space of potential circuit identities and the high computational resources required to generate these identities present significant hurdles. As the number of qubits $n$ and the circuit depth $d$ increase, the number of possible circuits grows exponentially, making it computationally expensive to handle larger circuits. Moreover, many useless identities are stored in the database, contributing to redundancy and inefficiency. Additionally, the tiling approach may limit the ability to find large-scale identities, as it is constrained by the maximum depth of circuit identities it can handle.

\begin{equation}
     S_{l} =\sum_{r=0}^{\lfloor n/2 \rfloor}\frac{n!}{r! (n-2r)!} g^{n-2r} t^r
\end{equation}

\begin{equation}
    S = S_{l}^{d}
\end{equation}

\begin{figure}
  \centering
  {\renewcommand{\arraystretch}{1.5}%
  \begin{tabular}{ | c | l | }
  \hline
  \thead{Symbol} & \thead{Definition} \\
  \hline
  $S$ & total number of possible circuits \\
  \hline
  $S_{l}$ & number of possible circuits per depth \\
  \hline
  $g$ & number of single-qubit gates \\
  \hline
  $n$ & number of qubits \\
  \hline
  $t$ & number of two-qubit gates \\
  \hline
  $S$ & number of possible circuits for the depth \\
  \hline
  $d$ & depth \\
  \hline
  \end{tabular}}
  \caption{\label{tab:scaling}Symbols for scaling formula}
\end{figure}

%-------------------------------------------------------------------------------
\section{Research proposal: Pruning Methods}
%------------------------------------------------------------------------------
\subsection{Motivation}
As stated in the Quanto Paper the number of possible circuits grows exponentially with an increasing number of qubits and
increasing circuit depth. In our opinion this is the biggest limiting factor for this type of optimization since it limits the possibilities to optimize larger circuits.\\

The original method introduced tiling as a work around while this greatly improves the level of optimization for larger circuits it still doesn't provide the same
quality of optimization and speed as a database of larger circuits would do.\\

Another Problem is the size of the database itself. The proposed algorithm in the Quanto paper stores all possible circuit in its database not only the most optimal ones. This adds a lot of redundancy to the database and slows down the optimization stage when looking for minimal identities.\\

Pruning the search space of all possible quantum circuit is in our opinion the most important factor fro improving the optimizer further and therefore worth investigating. 

\subsection{Implications and Limitations}
One important change that comes to the structure of the optimizer is that the dictionary that maps the circuits to its fingerprint cant be created and used any more. This is due to the fact that because of the pruning, the database generator won't iterate over all circuits and can't compute the mapping from circuits to fingerprints any more.

If we would create the dictionary in an additional step we could also group these circuits based on their equivalence with no significant expanse, making pruning basically useless.\\

In our research we limited ourselves to optimizing the depth of the circuit as it was the primary optimization goal of the Quanto optimizer. Further research is required if our approach is also feasible for other cost functions.

\subsection{Notations and Definitions}
Before going over the pruning technique, some words on definitions and important terms that are used in the following sections.

We use the same notation for the \textbf{gate set}, \textbf{depth} and \textbf{qubit number} as the Quanto paper does. \\

Additionally we define $C$ or $C^1$ as the set of all circuits with $n$ qubits and a depth of one and $C^k$ as all Circuits of length $k$. The $[a]_\sim$ Operator returns all circuits that are equivalent to $a$. We write $a\equiv b$ for $a$ being equivalent to $b$ ($a$ and $b$ have the same unitary matrix).\\

The cost function is generally denoted with $h(c)$ for a circuit $c$.

\begin{description}
	\item[optimal] A quantum circuit is called optimal if there exists no equivalent circuit (for a specified gate set) with lower cost
	
	\item[Column circuit] A circuit with maximum depth of one
\end{description}

For the concatenation of two circuits $a$ and $b$ with the same number of qubits we write $a\Vert b$. The gates of each circuit get appended \textit{qubit-wise}.


% -----------------------------------------------------------------------------------
\subsection{Challenges}
When we prune the search space of circuits we discard circuits we don't consider. When doing this we need to be careful that we still manage to reach all circuits 
(or equivalent circuits $[a]_\sim\space\forall a\in C^d$). The pruned database must also include all optimal circuits.\\

At the same time pruning adds overhead to the computation of the database. Se we need to make sure that the expense of these added computational steps don't exceed the advantages of the pruning.\\

Balancing these two aspects of cutting away enough to gain a net profit and leaving enough left to have all possibilities covered is the main challenge for this topic.

\subsection{Pruning Approach}
We started our research for pruning techniques by looking into the circuits of the Quanto database. A lot of the solutions in there are obviously not optimal or redundant: 

e.g. circuits including two \texttt{X} Gates concatenated or a column circuit only consisting of identity gates. \\

Investigating further into these redundancies, we found that most of the time, these non optimal circuits were part of larger structures. Replacing these \textit{subcircuits} with an optimal equivalent, would greatly improve the cost of the overall circuit. \\

On the other hand appending column circuits to a not optimal circuit can't result in an optimal one. Since if we do so anyways we could replace the suboptimal part with an optimal identity, lowering the total cost while maintaining the functionality of the circuit. Therefore there's no need to further consider these circuits in future iterations.\\

At the same time optimal interim results won't necessarily produce optimal end results. Take for instance a circuit with minimal cost that ends with a column of \texttt{X}-Gates. Appending another column of the same Gates will cancel each other out (since the \texttt{X}-Gate is self inverse) resulting in two unnecessary columns which can be removed.\\

For each iteration we could generate new circuits and check for each of them if there already exists a less expensive entry in the database. If so we can discard this new circuit. That would greatly reduce the number of possibilities to consider in the following iterations and limits the entries in the database to the most optimal ones.

\subsubsection{Proposed Algorithm}

The following code-segment shows a algorithm for generating the identity database with the described pruning technique:

\begin{verbatim}
function generateDatabase(n,d,gs){
	db = dict() 	# init database
	ws = dict() 	# init Working-Set
	ws[1] = generateColumns(n,gs)
	ws[1].remove([I,...,I]) 	# remove identity-c.
	
	for i in range(2,d) {
		for c in ws[i-1] {
			for r in ws[1] {
				c'=c||r
				if c' not in db {
					db[fingerprint(c')] = c'
					ws[i].add(c')
					continue
				}
				if isOptimal(c', db) {
					m = db[fingerprint(c')]
					db[fingerprint(c')] = c'	
					ws[i].add(c')
					ws[i].remove(m)
				}
	}}} 	# End for loops
} 	# End function
\end{verbatim}

The algorithm starts with initializing the database and a \textbf{working-set} dictionaries and generates all possible column circuits for \texttt{n} qubits and a gate-set using the \texttt{generateColumns(n,gs)} function. It also removes the column circuit that only consists of identity gates.\\

Next, the program iterates over the depth levels starting with a depth of two up to the maximum depth \texttt{d}. For each iteration we take each element from the working-set of the previous round and append each column circuit to it. For each of these newly generated circuits the algorithm checks if there already exists an equivalent circuit in the database. \\

If the circuit is completely new it gets added to the current working-set and the database. 

If there exists an equivalent circuit we check if the new circuit has lower costs than the existing one, if so we replace it in the database and if applicable in the current working-set. 

If there exists an optimal solution we don't add the new solution to the current working-set and continue. By doing this we ensure that this circuit wont get used in future rounds.\\

The \texttt{isOptimal(c,db)} method, checks if \texttt{c} is optimal with regards to the current database \text{db} and returns a boolean respectively.\\

It follows from the definition of the algorithm that every element in $ws[i]\space\forall i$ is optimal. The same holds for the database entries.

% For every existing circuit with $n$ Qubits and depth $d$ there exists at lease an equivalent circuit in the pruned database. To show that we assume that there exists a circuit $a\Vert b$ of depth $j$ with $a\not\in ws[j-1]$. Then because of the definition of the algorithm we know that there must already exist an equivalent circuit in our database $a'$. From that it follows that $a'\Vert b\equiv a\Vert b$. Either $a'\Vert b$ is optimal and therefore in the database or there already exists an equivalent optimal circuit $c$ with $c\equiv a\Vert b$

\subsubsection{Evaluation}
The amount of the saving depends on the depth of the circuit and the number of qubits but also on the used gate set, which makes it hard to quantify. 

However we can say that for $S_l$ column circuits the removal of one circuit in the k-th iteration, results in $S_l^{d-k}$ less circuits the algorithm iterates over.\\

The size of the final database also greatly decreased since only optimal circuits are stored. This should also speed up the circuit selection part in the optimization phase.

\subsubsection{Implementation}
We've implemented the proposed algorithm from above in python based on the Qiskit and Numpy frameworks. The resulting software is a prototype just for the identity database generation. We decided to exclude the optimization part since it was too much work and didn't differ in comparison to the original algorithm. Our implementation includes both the original database generation algorithm from Quanto and our pruning approach.

%-------------------------------------------------------------------------------
\bibliographystyle{plain}
\bibliography{\jobname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%  LocalWords:  endnotes includegraphics fread ptr nobj noindent
%%  LocalWords:  pdflatex acks
